# Bitcoin

<br>![miscellaneous image](https://raw.githubusercontent.com/AnselmoGPP/Learn_Computer_Science/master/resources/miscellany.jpg)


## Table of Contents

+ [**References**](#references)
+ [**History of money**](#history-of-money)
+ [**Introduction**](#introduction)
+ [**Basics**](#basics)


## References:

- Harsh Strongman (2022) *Teach yourself crypto*. Retrieved from [teachyourselfcrypto.com](https://teachyourselfcrypto.com/).

- **Introduction**
  - [History and evolution of money](https://lifemathmoney.com/the-history-and-evolution-of-money/)
  - [How does BTC actually work?](https://www.youtube.com/watch?v=bBC-nXj3Ng4)
  - [Bitcoin - Cryptographic hash function](https://www.youtube.com/watch?v=0WiTaBI82Mc)
  - [How secure is 256 bit security?](https://www.youtube.com/watch?v=S9JGmA5_unY)
  - [Public key cryptography](https://www.youtube.com/watch?v=GSIDS_lvRv4)
  - [What are digital signatures?](https://www.youtube.com/watch?v=s22eJ1eVLTU)
  - [The GNU privacy handbook](https://gnupg.org/gph/en/manual.pdf)
- **Basics**
  - [Basic concepts](https://youtu.be/FYo5E7zT-vM)
  - Decentralized consensus
    - [Bitcoin blockchain consensus](https://www.youtube.com/watch?v=f1ZJPEKeTEY)
    - [Consensus definition](https://en.bitcoin.it/wiki/Consensus)
    - [Fork definition](https://en.bitcoin.it/wiki/Fork_(disambiguation))
    - [Nakamoto consensus](https://blockonomi.com/nakamoto-consensus/)
- **Nodes**
  - [Role of nodes](https://www.youtube.com/watch?v=fNk7nYxTOyQ)
  - [Types of nodes and forks](https://nodes.com/)
- **Proof of work and consensus**
  - [Byzantine fault tolerance](https://www.youtube.com/watch?v=VWG9xcwjxUg)
  - [Proof of work](https://www.youtube.com/watch?v=9V1bipPkCTU)
  - [A 51% attack](https://www.youtube.com/watch?v=BuTj9raHQOU)
- **Bitcoin wallets**
  - [Bitcoin wallet](https://www.youtube.com/watch?v=A1Pl5hYHXiI)
  - [Wallets: Visual explanation](https://www.youtube.com/watch?v=d8IBpfs9bf4)
- **Bitcoin whitepaper**
  - [Bitcoin white paper](https://bitcoin.org/bitcoin.pdf)
  - [Bitcoin white paper made simple](https://static1.squarespace.com/static/567bb4f069a91a95348fa0b2/t/5cd27c8bb208fcb3a45d2196/1557298317565/Intrepid+Ventures+Bitcoin+White+Paper+Made+Simple.pdf)
- **Extending bitcoin**
  - [BIP approval process](https://www.youtube.com/watch?v=NJqAuZGg1gU)
  - [BIP list (for reference)](https://github.com/bitcoin/bips)
  - [Layer 2 solutions](https://www.cryptovantage.com/news/ask-cryptovantage-what-is-bitcoins-layer-2/)
- **Scalability**
  - Lightning network
    - [Introduction](https://www.youtube.com/watch?v=rrr_zPmEiME)
    - [Understanding the bitcoin lightning network](https://jaspa.codes/site/2021/01/11/lightning-network.html)
    - Understanding the Lightning network [[Part 1](https://bitcoinmagazine.com/technical/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-1464710791)] [[Part 2](https://bitcoinmagazine.com/technical/understanding-the-lightning-network-part-creating-the-network-1465326903)] [[Part 3](https://bitcoinmagazine.com/technical/understanding-the-lightning-network-part-completing-the-puzzle-and-closing-the-channel-1466178980)]
  - Segwit
  - Block size increase (Bitcoin Cash, Bitcoin Satoshi Vision)
  - Schnorr signatures
  - Side chains
  - Colored coins
    - [Omni layer](https://www.omnilayer.org/)
- **Advanced bitcoin**
  - Transactions (pre-Segwit) [[Part 1](https://www.youtube.com/watch?v=Em8nJN8IEes&t)] [[Part 2](https://www.youtube.com/watch?v=f9nxuhLSyOg)]
  - Segwit
    - [Transaction malleability](https://www.coindesk.com/bitcoin-bug-guide-transaction-malleability)
    - [What is Segwit](https://www.youtube.com/watch?v=f3CFUbeehc8)
  - [The script language](https://youtu.be/6Fa04MnURhw)
  - [More Segwit](https://medium.com/softblocks/segregated-witness-for-dummies-d00606e8de63)
  - Merkle trees
    - [Merkle roots and Merkle trees](https://www.youtube.com/watch?v=gUwXCt1qkBU)
    - [Merkle proofs](https://www.youtube.com/watch?v=2kPFSoknlUU)
    - [Data corruption and Merkle trees](https://www.youtube.com/watch?v=rsx1nt2bxf8)
    - [How SPV nodes use Merkle trees](https://www.yourdevopsguy.com/merkle-trees-and-bitcoin/)
    - [How SPV nodes communicate with full nodes](https://www.youtube.com/watch?v=WSlvBfLGU5I)
  - Bloom filters
    - [What are bloom filters and why they exist](https://www.youtube.com/watch?v=gBygn3cVP80)
    - [Bloom filters and SPV nodes within the Bitcoin blockchain](https://tara-annison.medium.com/bloom-filters-and-spv-nodes-within-the-bitcoin-blockchain-66c36ea673f2)
    - [Bloom filters and SPV](https://www.yourdevopsguy.com/bloom-filters-and-bitcoin/)
  - [Elliptic curve cryptography](https://www.youtube.com/watch?v=dCvB-mhkT0w)
- **Future of Bitcoin**
  - [Quantum computing risks](https://www.youtube.com/watch?v=wlzJyp3Qm7s)
  - [Schnorr signatures](https://bitcoincore.org/en/2017/03/23/schnorr-signature-aggregation/)
  - [Taproot](https://bitcoinmagazine.com/technical/taproot-coming-what-it-and-how-it-will-benefit-bitcoin)
- **FAQ**
  - [Can you spend unconfirmed receipts?](https://bitcoin.stackexchange.com/questions/69937/accidentrally-spent-from-unconfirmed-transaction)
  - [What happen if your transaction is never confirmed?](https://bitcoin.stackexchange.com/questions/21901/what-happens-if-your-transaction-is-never-confirmed)
  - [Why does each block store a Merkle root?](https://bitcoin.stackexchange.com/questions/48928/why-does-each-block-store-a-merkle-root)
  - [What's the difference between SegWit and Native SegWit address?](https://www.ledger.com/academy/difference-between-segwit-and-native-segwit)
  - [Electrical consumption](https://news.bitcoin.com/bitcoin-energy-consumption-is-far-more-efficient-and-greener-than-todays-banking-system/)
  - [Coins and Tokens](https://www.youtube.com/watch?v=c7TsIb8KyB8)
  - [Incentives](https://www.youtube.com/watch?v=Q8KtQ3uM1tk)
  - [Is Bitcoin ruled by miners?](https://en.bitcoin.it/wiki/Bitcoin_is_not_ruled_by_miners)
  - [What is economic majority?](https://en.bitcoin.it/wiki/Economic_majority)
  - [Common myths about Bitcoin](https://en.bitcoin.it/wiki/Myths)
- **History**
  - Satoshi Nakamoto
  - [Bitcoin auction: 10.000.000 BTC - Starting bid 50.00 USD](https://bitcointalk.org/index.php?topic=92.0)
  - [The Bitcoin pizza](https://www.cryptowisser.com/the-story-of-the-bitcoin-pizza/)
  - [History of Bitcoin](https://en.wikipedia.org/wiki/History_of_bitcoin)
  - [Mt. Gox](https://www.youtube.com/watch?v=9lJP22qa6Ak)
  - [The long road to SegWit](https://bitcoinmagazine.com/technical/the-long-road-to-segwit-how-bitcoins-biggest-protocol-upgrade-became-reality)
  - [Bitcoin Cash (BCH)](https://en.wikipedia.org/wiki/Bitcoin_Cash)
  - [Bitcoin SV (BSV)](https://www.youtube.com/watch?v=4VWtZpIJPRM)


## History of money

Humans are not self-sufficient, nor can exist in isolation. We need things other humans provide, and we provide things other humans need. We do **exchanges** (you give something you have in order to get what you want). Eventually, we invented agriculture and domesticated animals, so we were able to settle down at one place and created a society. Our labor became specialized (farmers, doctors, fishermen...), which increased productivity and quality of goods produced. 

**Barter system**: Until a few thousand years ago, human's exchange system was the barter system (we exchange goods and services with each other directly). The exchange ratio was determined based on demand and supply. However, it had limitations: no common measure of value (each good was pegged to different sets of other goods: 1 wheat bag = 2 fish or 5 haircuts or 4 pots...), need of double coincidence of wants (both parties need what the other provides), indivisibility of certain goods (if my goat is worth 10 pots, I cannot get 5 pots), lack of standards for deferred payments (credit transactions involve disputes about the quality and value of goods used), and storage problems (storing wealth is complicated: stored fishes will spoil).

**Commodity money**: These issues can be solved by using a widely consumed commodity that's always in demand and can be exchange for other goods. Romans used salt (divisible, non-perishable, limited, widely consumed), which was called *salarium* and is the origin of the word "salary". India used cattle. Virginia used tobacco. Carolina used rice. Africa used cowry shells. Brazil used sugar. Mongolia used tea. Anything can be "money" as long as enough people accept it in exchange for their goods and services. Money does not have to be backed by a government to be considered money. Commodities have limitations: storage issues, difficult to transport over long distances, no universal acceptability, and perishability.

**Metallic money**: It's a form of commodity money. Metals (like gold) are valuable, durable, divisible, fungible, homogeneous, scarce, and it's easy to verify its purity. However, they are heavy.

**Gold backed IOUs (Non-legal tender paper currency): To prevent theft, people would leave their gold with a goldsmith, who accepts it for a fee and issues a IOU (I Owe You) note. Anyone with a IOU note can retrieve the gold from the goldsmith. Eventually, IOU notes were accepted as payments. These goldsmiths eventually realized that not everybody claimed their gold at one time, and they had a healthy balance of gold, so they started creating fake IOU notes not backed with any gold. The ratio of gold obligated to repay and the actual gold they had in the vault kept deteriorating and, occasionally, the goldsmiths disappeared overnight along with all the gold, making IOU notes worthless.

**Legal tender coinage**: Fraudsters used metallic money to cheat the public in purity or weight (mix precious metals with less precious metals). The governments decided to solve this by taking control of metallic money minting and stamping them with symbols that guarantee their weight and purity. Problem: it was centralized. Governments ended up debasing the currency (mixing precious metals) whenever they needed money, which increased money supply, decreased value of precious metals in the coins, hurt trust in the currency, deteriorates international trade, and causes domestic inflation.

**Paper money**: The oficial Chinese government currency had copper. It was difficult to use them for large transactions because they were heavy, so some people left their coins to trusted agent who would issue paper promissory notes, which could be used as a currency. It was easy to store, to transport, to carry, to divide, and was not perishable. Eventually, the Chinese emperors issued a nationwide paper currency standard backed by gold or silver that was legal tender (i.e., recognized by law as a mean to settle debt or meet financial obligations). Problem: it was centralized. Whenever the state needed money, they printed more currency, which led to oversupply and hyperinflation. The currency became worthless and China discontinued the use of paper currency in 1455. They would not adopt it again for hundreds of years.

Differences between **money** and **currency**: 

- **Money**: Item of verifiable record that is generally accepted as payment for goods and services and repayment of debts (such as taxes) in a country or socio-economic context. Main functions: medium of exchange, unit of account, store of value, standard of deferred payment (sometimes). It's intrinsically valuable and is a store of value. Example: gold.

- **Currency**: System of money (monetary units) in common use, specially for people in a nation. Monetary unit (in any form) used as a medium of exchange (usually referred to coins and banknotes). Example: dollar.

**Paper money in USA**: In 1690, the colonies started printing paper money denominated in pounds (each colony had its own). However, they printed too much, causing inflation and currencies devaluation. The British parliament ended this money printing with some "Currency acts". During the American Revolution, they states and the Continental congress issued paper money again. Soon, they printed too much and it became worthless by the end of the war. After the war, they created the current dollar, which was based on the Gold Standard (i.e., it represented actual gold and silver the government had in its vaults). But, whenever more money was needed, the government printed more money, reducing the amount of gold each dollar was worth. Many countries started cashing in dollars for actual gold, leading to the collapse of the Gold Pool. In 1971, the government ended the direct convertibility of gold to dollars (Nixon Shock), making the dollar a fiat currency.

**Fiat money**: Currency established as money by government regulation. It has no intrinsic value (no inherent utility) and is not backed by any physical commodity. It has value because parties engaging in exchange agree on its value and the government maintains its value by controlling money supply through a central bank. Virtually all countries follow this model. Problem: it's centralized and they print too much.

**Plastic money**: Money can be kept on banks and, instead of using notes, we can use plastic cards (ATM cards, debit cards, credit cards...) to spend money directly from the bank.

**Digital currencies**: People has tried to create a fully digital currency using computers and internet (like E-gold in 1996). However, it was difficult to solve the *double-spending problem* (computers make it easy to copy files, and it's not clear how to ensure that you cannot spend the same currency twice). Early digital currencies solved this by having a central organization that verifies it. This system works, but it has a single point of failure: the central organization. Hackers would target this central organization, worried governments would litigate and shut them down, and sometimes the parent company would suddenly liquidate.  

**Bitcoin**: It was needed a decentralized system that solved the double-spending problem, that could not be targeted by a government or hacker, and without a parent company. Bitcoin is a decentralized currency that solved this problem using **blockchain** and **proof of work**.


## Introduction

Bitcoin is a fully digital currency. There's no government issuing it, and no bank verifying transactions. Instead, there's a clever system of decentralized trustless verification based on some cryptography math.

Consider a group of people that make exchanges between each other. All exchanges are registered in a ledger. All participants maintain a ledger with all transactions in the group. The currency IS the ledger itself. Protocol:

- Anyone can add lines to the ledger
- Only signed transactions are valid
- No overspending

**Digital signatures**: To prevent fraudulent lines being added, a payer must sign his payments. Each participant has a pair **Private key** and **Public key** (two strings of bits). The public key can be known by anybody. The private key is secret and only known by this owner. 

- `sign(message, privKey) = signature`: The private key together with the message produce a signature, which is different for each message. This way, nobody can sign a message with your private key, nor produce the same signature as you. 

- `verify(message, signature, pubKey) = true/false`: The signature can be verifies using the message, signature, and public key. 

It's completely infeasable to find a valid signature without knowing the secret key (there's no better strategy than guessing and checking random signatures). Also, to ensure that one signed transaction is not copy-pasted, each transaction includes an id, which requires a different signature even for identical transactions.

**Decentralization**: Each participant holds their own copy of the ledger, which removes the need of trust. When A pays something to B, this transaction is broadcasted into the world, so everybody put it into their ledgers. 

**Hash function**: Function that takes an input (any kind of message) and outputs a string of bits of fixed length (called hash, or digest) that looks random. It always gives the same output for the same input. The slightest change of the input produce a completely different unpredictable output.

- **Cryptographic hash function**: Hash function where reversing the process (converting hash to input) is infeasible. The only way would be to guess and check inputs. Example: `SHA256()` produces a hash of 256 bits. A 256 bit signature has 2<sup>256</sup> possible signatures.

**Proof of work** (PoW): How to ensure that everybody receive the same transactions in the same order? Basically, we trust the ledger that has the most computational work put into it. This also makes fraudulent transactions and conflicting ledgers require an infeasible amount of computation to bring about. 

- At the end of a list of transactions (block) we put a number (called PoW) and encrypt the block with a cryptographic hash function. This PoW have to make the hash begin by a certain number of zeros. To find out the PoW we have to guess and check a lot of numbers until we get the hash we look for. The probability of finding a number that produces 30 heading zeros is 1/2<sup>30</sup>. 

- Finding the PoW is expensive, but verifying it is easy. This work is intrinsically tied to the list of transactions. Modifying one transaction changes the hash completely, which also requires to compute the PoW again.

- The number of zeros a PoW must create is changed periodically so it takes 10 minutes on average to find a new block.

**Blockchain**: Data structure of the ledger. Each valid block of transactions has a PoW at the end. To ensure the order of the blocks, each block also contains the hash of the previous block at its header. So, if somebody wants to modify a block, he will need to compute the PoW of that block and the following ones. When somebody finds out the block's PoW, he broadcasts the block to the rest of the world so everybody copy it to the blockchain. You can check blocks information at [BlockExplorer](https://blockexplorer.one/).

**Miners**: Those creating new blocks, looking for a **block reward** and **fees**. Not everybody are miners. Those making transactions just listen for blocks broadcasted by miners and update their own personal copies of the blockchain. If you hear two distinct blockchains with conflicting transaction histories, you take the longest one (who has the most work put into it). If they have the same length, just wait until one of them is longer. This provides a decentralized consensus (we don't trust a central authority but computational work). 

- **Block reward**: The one who finds the PoW gets a **block reward** (he's allowed to put a special non-signed transaction at the top of the block were he gets some money from nobody), incrementing the total money supply.

- **Transaction fee**: When you make a transaction, it can optionally include a fee with it that will go to the miner that includes your transaction in a block. Each block is limited to ~2400 transactions (Visa is capable of handling >24.000/s), which is slow and makes for bigger fees.

Fraud example: Imagine miner A wants to fool B by sending him a block with A paying something to B. The other miners won't be aware of this payment. For A to keep the fraud alive, he would have to keep finding the subsequent PoWs faster than the other miners so his blockchain is longer (only possible with >50% of computing power).

**Bitcoin protocol**: The ledger is the currency (it is functional per se, without needing to transform it to another currency). It's based on digital signatures and a PoW. The data structure of the ledger is the blockchain. It's decentralized.



-----



**Hash function**: Function that takes an input (message) of arbitrary length, transforms it, and outputs a value (digest, hash, tag, fingerprint) of fixed length (example: HASH-256 function outputs a 256 bit digest). It's a deterministic function (i.e., the output will always be the same for a given input).

**Cryptographic hash function**: It's a hash function design for applications that require cryptography, security, privacy confidentiality, or authentication. Some of the most common ones are **MD5** (and predecessors like MD4) and **SHA-256** (and predecessors like SHA-1). They are key building blocks in many algorithms and protocols, which are critical in many applications: digital signatures (in bitcoin, e-commerce protocols, …), message authentication protocols, pseudorandom number generation, password security, encryption, etc. 

**Digital signature** use cryptographic hash functions that must be:

- Computationally efficient: Fast to compute.
- Collision resistant: It must be astronomically hard to find two inputs that map to the same output.
- It must hide any information about the inputs.
- Output must be well distributed. It must look random. It must not be predictable. It must look unrelated to the input.

There's no mathematical proof that these techniques are secure. We trust them based on how long they've been around.

**Symmetric encryption**: A and B share a secret key (they had a secret meeting in advance) that they use to encrypt and decrypt the messages they send to each other.

**Asymmetric encryption**: There is a key pair (X, Y) such that any of these keys can be used to encrypt a message, but only the other key can decrypt it. It's not possible to guess one key from the other. 

- **Public key cryptography** (PKC): Once we generate a key pair, we take one as **public key** (PK) (you can publish it anywhere with your name on it) and the other as **private/secret key** (SK) (kept secret). There is no need to have a secret meeting in advance to share any secret key. Uses:

  - Encrypt a message with your public key &rarr; This guarantees that only you can decrypt the message.
  - Encrypt a message with your SK &rarr; It's guaranteed that you are the author of the message, and anyone can decrypt it with your PK.
  - Encrypt a message with your SK, and then again with your friend's PK &rarr; This guarantees that you're the author, and that only your friend can decrypt it (with his SK and your PK).

Public key cryptography (like RSA) can be too slow for communicating long messages. Instead, we usually use asymmetric cryptography for verifying one party and exchanging a key, and then we continue communication using symmetric cryptography (like AES). Example: Part of the TLS protocol (between HTTP and TCP) is a certificate and a digital signature, and it takes part in a handshake.

**Private signature**: During a handshake, A wants to confirm to B who he is, so A uses his SK to encrypt a message known by both, and sends it to B. Then B can decrypt it using A's PK and check whether it is identical to the original message. However, signature schemes (like RSA) don't work well with too long (slow encryption) or short (less random encryption) messages so, before encrypting the message we apply a hash function to it (like SHA256) so it becomes a hash of a given length. Since 256 bits is quite short for this kind of signature scheme (we want to avoid a hash that is a small number because it's a security risk), we increase its length by adding some padding or applying a similar mechanism.

- Example 1: In TLS, you exchange a bunch of messages. At some point, you send a certificate containing a PK and a Certificate verify message (TLS 1.3) containing a message (summary of the previous messages, hashed, padded, and encrypted with your SK).

- Example 2: We have a certificate for a server backed by a SK kept on the server. This certificate holds their public key, and a digital signature signed by some certification authority. So, when you do a handshake and the server sends you the certificate, you can verify (take the content of the certificate, hash it, pad it, decrypt it using his PK, and compare them) that it was properly signed by the certification authority you trust.


## Basics

**Bitcoin**: Protocol for a decentralized peer-to-peer network that creates consensus without needing a central authority to provide trust.

**bitcoin** (BTC): Currency (token) issued as a reward in the proof-of-work mining process. For plural, don't use s suffix ("I have 3 bitcoin").

**Blockchain**: Public ledger where the network records (transactions) are written.

How do people acquire bitcoin?

- __Earn__: Get paid in bitcoin: Offer a service, sell a product, or get wages paid in bitcoin ([bitwage.com](https://www.bitwage.com/)).
- __Buy__: Exchange national money (fiat) for bitcoin (from an exchange, from a bitcoin ATM, or from another person directly from cash).
- __Trade__: Trade your belongings for bitcoin (sell car, sell house...).

Bitcoin doesn't have a price (commodities do) but an exchange rate (because it's money).

**Price discovery**: The market doesn't set the price/exchange rate, but discovers it. Markets find out what the real value of something is by looking at market movement. The current price is the average of the prices that people agreed and traded on over the past period of time (it can be seen in the Order book).

**Order book**: Graph that shows the buy and sell orders. It looks like two lines separating from the centre and increasing height.

**Spread**: Difference between bid (buy) price and ask (sell) price (example: A wants to sell at 15$ but B wants to buy at 15$, so spread = 5$). Buyers and sellers change their orders until they agree on a price.

**Bitcoin ATM**: ATM machine that exchanges you fiat money for BTC. It has a slot for introducing money, and a camera for scanning a QR code representing a BTC address. It connects to the Internet to use some price provider (such as [bitcoinaverage.com](https://bitcoinaverage.com/)).

**BTC address**: Public identifiable number generated from a SK (the oppossite isn't possible). It's possible to make transfers to/from this address. The owner/s of this address are those who know its SK. Anybody can see its content (amount of BTC) and make transfers to this address, but only the owner/s can transfer from it. A BTC address tells you nothing about the SK. 

The **SK* is 256 bits (77 decimal digits). For convenience (shorter numbers), we represent it using base-58 (each digit is 1 out of 58 possible digits: 26 uppercase letters + 26 lowercase letters + 10 numbers - L - l - O - o), resulting in a 42 character number.

When somebody transfer BTC, they're transfer them to a BTC address. The BTC are always in the blockchain (not my pocket, not my wallet...). Anybody can send BTC to any BTC address.

**Satoshis**: It's the only money unit that actually exist in the system (1 BTC = 100 million sat.). BTC doesn't exist, satoshis do. Nowhere in the BTC system there is a unit of BTC, everything is measured in satoshis.

- 1 BTC = 1000 millibit
- 1 millibit = 1000 bits
- 1 bit = 100 satoshis

Currently, BTC is not a good unit of account yet because it's **volatile**, due to the small size of the market. This makes it difficult to price things. Also, BTC is not legal tender (it's not accepted for paying taxes).

**Bech-32** (Native segwit address): Type of BTC address that uses a 32 character encoding (no uppercase letters used), which has some properties for error correction. Most wallets use this format. It uses prefix bc1q.

**Transaction process**: When a transaction is made, it's required to spend all the money in the origin address. Otherwise, what the wallet does is to send the amount you want to send to the destination address and the rest to an address of yours (called change address), except for a small amount that is left untouched for the miners to take (fee). If a change address is not provided, all of the rest is left for the miners as fee.

- __Input__: Satoshis that are sent to your address (example: an ATM sends satoshis to your address).
- __Output__: Satoshis sent to destination address + those sent to change address (the fee is left behind).

Blocks activity can be explored with tools such as [blockstream.com](https://blockstream.info/).

**Transaction fees** are necessary because there's a limited space for transactions (by physics, technology, and software). Fees determine who values their transaction more, and support mining as issuance declines.

**Mempool** (queue): When transactions are transmitted into the BTC blockchain they're not automatically included in the very first block because usually there're more transactions and all of them doesn't fit in a block. So, these transactions wait in each node's **mempool** until they're included in the blockchain. The higher the fee, the sooner the transaction is included in a block.

**Confirmations**: At the beginning, the transaction is unconfirmed (still in the mempool, not mined in a block yet). Once it appear in a block, it has 1 confirmation. And the more blocks are mined on top of it, the more confirmations it gets.

BTC works as a **broadcast network** (flood/gossip protocol), which means that any transaction sent to the BTC network is shouted. The wallet sends the transaction to all the BTC nodes it is connected to. These nodes confirm the transaction's validity and send it to all the nodes they're connected. An so on. In ~15 seconds it's spread to the entire BTC network.

For large transactions (TV, car, house...) people may want to wait for several confirmations, which takes time. With little transactions (coffee, pencil, candy...) we usually don't care about confirmations (most probably it will get into a block). The higher the risk, the more confirmation me require. 

**Settlement (or clearing)**: Finalization of a transaction. Moment at with the transaction is no longer reversible. A credit card transaction is approved in a few seconds, but it takes 60 days to clear/settle. Retail transactions are not instantaneous (except if it's cash), but they look so.

Bob pays 






